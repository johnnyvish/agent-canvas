===== File: app/layout.tsx =====
Type: .tsx
----- Content Start -----
import type { Metadata } from "next";
import localFont from "next/font/local";
import "./globals.css";
import { ApiKeyProvider } from "@/contexts/ApiKeyContext";

const geistSans = localFont({
  src: "./fonts/GeistVF.woff",
  variable: "--font-geist-sans",
  weight: "100 900",
});
const geistMono = localFont({
  src: "./fonts/GeistMonoVF.woff",
  variable: "--font-geist-mono",
  weight: "100 900",
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <ApiKeyProvider>{children}</ApiKeyProvider>
      </body>
    </html>
  );
}

----- Content End -----

===== File: app/page.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import FlowEditor from "@/components/FlowEditor";

export default function Home() {
  return <FlowEditor />;
}

----- Content End -----

===== File: app/globals.css =====
Type: .css
----- Content Start -----
@tailwind base;
@tailwind components;
@tailwind utilities;

----- Content End -----

===== File: components/useFlowEditorLogic.tsx =====
Type: .tsx
----- Content Start -----
// types.ts
type NodeData = {
  label: string;
  systemPrompt: string;
  userQuery?: string;
  isRoot: boolean;
  output?: string;
  isProcessing?: boolean;
  error?: string;
};

type LLMResponse = {
  output: string;
  error?: string;
};

// llmService.ts
const simulateLLMResponse = async (
  systemPrompt: string,
  input: string
): Promise<LLMResponse> => {
  // Simulate API delay
  await new Promise((resolve) => setTimeout(resolve, 1000));

  // Simulate response
  return {
    output: `Simulated response for input: "${input}" with system prompt: "${systemPrompt}"`,
  };
};

// useFlowEditorLogic.tsx
import { useCallback, useState } from "react";
import {
  useNodesState,
  useEdgesState,
  addEdge,
  Node,
  Edge,
  Connection,
  getOutgoers,
} from "@xyflow/react";

const initialNodes: Node<NodeData>[] = [
  {
    id: "1",
    type: "customNode",
    position: { x: 200, y: 50 },
    data: {
      label: "Root Node",
      systemPrompt: "You are a helpful assistant.",
      userQuery: "What are the implications of AI?",
      isRoot: true,
      output: "",
      isProcessing: false,
    },
  },
];

const initialEdges: Edge[] = [];

export default function useFlowEditorLogic() {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);
  const [isProcessing, setIsProcessing] = useState(false);

  // Process a single node
  const processNode = async (
    node: Node<NodeData>,
    input: string
  ): Promise<string> => {
    // Update node to show processing state
    setNodes((nds) =>
      nds.map((n) =>
        n.id === node.id
          ? {
              ...n,
              data: { ...n.data, isProcessing: true, error: undefined },
            }
          : n
      )
    );

    try {
      const response = await simulateLLMResponse(node.data.systemPrompt, input);

      // Update node with response
      setNodes((nds) =>
        nds.map((n) =>
          n.id === node.id
            ? {
                ...n,
                data: {
                  ...n.data,
                  output: response.output,
                  isProcessing: false,
                },
              }
            : n
        )
      );

      return response.output;
    } catch (error) {
      // Update node with error
      setNodes((nds) =>
        nds.map((n) =>
          n.id === node.id
            ? {
                ...n,
                data: {
                  ...n.data,
                  error: "Error processing node",
                  isProcessing: false,
                },
              }
            : n
        )
      );
      throw error;
    }
  };

  // Process the entire flow starting from root nodes
  const processFlow = async () => {
    if (isProcessing) return;
    setIsProcessing(true);

    try {
      // Find all root nodes
      const rootNodes = nodes.filter((node) => node.data.isRoot);

      // Process each root node and its descendants
      for (const rootNode of rootNodes) {
        await processNodeAndDescendants(rootNode);
      }
    } catch (error) {
      console.error("Error processing flow:", error);
    } finally {
      setIsProcessing(false);
    }
  };

  // Recursively process a node and its descendants
  const processNodeAndDescendants = async (node: Node<NodeData>) => {
    // Get the input for this node
    const input = node.data.isRoot
      ? node.data.userQuery || ""
      : node.data.output || "";

    // Process the current node
    const output = await processNode(node, input);

    // Get all outgoing nodes
    const outgoers = getOutgoers(node, nodes, edges);

    // Process all outgoing nodes
    for (const outgoer of outgoers) {
      await processNodeAndDescendants(outgoer as Node<NodeData>);
    }

    return output;
  };

  // Rest of your existing functions...
  const onConnect = useCallback(
    (params: Connection | Edge) => setEdges((eds) => addEdge(params, eds)),
    [setEdges]
  );

  const handleAddNode = useCallback(
    (isRoot: boolean) => {
      const id = (nodes.length + 1).toString();
      const newNode: Node<NodeData> = {
        id,
        type: "customNode",
        position: {
          x: Math.random() * 500 + 50,
          y: Math.random() * 500 + 50,
        },
        data: {
          label: isRoot ? "Root Node" : "New Node",
          systemPrompt: isRoot
            ? "You are a helpful assistant."
            : "Default prompt",
          isRoot,
          output: "",
          isProcessing: false,
        },
      };
      setNodes((ns) => [...ns, newNode]);
    },
    [nodes, setNodes]
  );

  return {
    nodes,
    edges,
    onNodesChange,
    onEdgesChange,
    onConnect,
    handleAddNode,
    processFlow,
    isProcessing,
  };
}

----- Content End -----

===== File: components/CustomNode.tsx =====
Type: .tsx
----- Content Start -----
import React, { useState, useEffect } from "react";
import { Handle, Position, useReactFlow } from "@xyflow/react";
import { NodeForm } from "./NodeForm";
import { NodeOutput } from "./NodeOutput";
import { NodeData } from "../types/flowTypes";

type CustomNodeProps = {
  id: string;
  data: NodeData;
  selected: boolean;
};

export const CustomNode: React.FC<CustomNodeProps> = ({
  id,
  data,
  selected,
}) => {
  const [systemPrompt, setSystemPrompt] = useState(data.systemPrompt);
  const [userQuery, setUserQuery] = useState(data.userQuery || "");

  // use ReactFlow's setNodes to update the global node state
  const { setNodes } = useReactFlow();

  const updateNodeData = (changes: Partial<NodeData>) => {
    setNodes((nds) =>
      nds.map((node) =>
        node.id === id ? { ...node, data: { ...node.data, ...changes } } : node
      )
    );
  };

  useEffect(() => {
    setSystemPrompt(data.systemPrompt);
    setUserQuery(data.userQuery || "");
  }, [data.systemPrompt, data.userQuery]);

  return (
    <div
      className={`w-60 p-4 bg-gray-800 text-white flex flex-col items-center justify-center shadow-2xl rounded-2xl cursor-pointer gap-6 relative 
        ${
          data.isProcessing
            ? "border-2 border-blue-500"
            : data.error
            ? "border-2 border-red-500"
            : selected
            ? "border-2 border-yellow-500"
            : "border-2 border-transparent"
        }`}
    >
      {!data.isRoot && (
        <Handle
          type="target"
          position={Position.Left}
          style={{ background: "#555", width: 20, height: 20 }}
        />
      )}
      <Handle
        type="source"
        position={Position.Right}
        style={{ background: "#555", width: 20, height: 20 }}
      />

      <div className="absolute top-3 right-3">
        <div
          className={`w-4 h-4 rounded-full ${
            data.isProcessing
              ? "bg-blue-500 animate-pulse"
              : data.error
              ? "bg-red-500"
              : data.output
              ? "bg-green-500"
              : "bg-gray-600"
          }`}
        />
      </div>

      <h1 className="font-bold">{data.label}</h1>

      <NodeForm
        data={data}
        systemPrompt={systemPrompt}
        userQuery={userQuery}
        setSystemPrompt={setSystemPrompt}
        setUserQuery={setUserQuery}
        updateNodeData={updateNodeData}
      />

      <NodeOutput data={data} />
    </div>
  );
};

----- Content End -----

===== File: components/NodeOutput.tsx =====
Type: .tsx
----- Content Start -----
import React from "react";
import { NodeData } from "../types/flowTypes";

type NodeOutputProps = {
  data: NodeData;
};

export const NodeOutput: React.FC<NodeOutputProps> = ({ data }) => (
  <div className="flex flex-col justify-center items-center w-full gap-2">
    <h2 className="text-md font-semibold">Output</h2>
    <textarea
      value={data.output || ""}
      readOnly
      className={`w-full h-24 rounded-lg text-black text-sm px-2 py-2 resize-none overflow-auto
        ${data.error ? "bg-red-100" : "bg-white"}`}
    />
    {data.error && <p className="text-red-500 text-sm">{data.error}</p>}
  </div>
);

----- Content End -----

===== File: components/NodeForm.tsx =====
Type: .tsx
----- Content Start -----
import React from "react";
import { NodeData } from "../types/flowTypes";

type NodeFormProps = {
  data: NodeData;
  systemPrompt: string;
  userQuery: string;
  setSystemPrompt: (value: string) => void;
  setUserQuery: (value: string) => void;
  updateNodeData: (changes: Partial<NodeData>) => void;
};

export const NodeForm: React.FC<NodeFormProps> = ({
  data,
  systemPrompt,
  userQuery,
  setSystemPrompt,
  setUserQuery,
  updateNodeData,
}) => (
  <>
    <div className="flex flex-col justify-center items-center w-full gap-2">
      <h2 className="text-md font-semibold">System Prompt</h2>
      <textarea
        value={systemPrompt}
        onChange={(e) => {
          const newPrompt = e.target.value;
          setSystemPrompt(newPrompt);
          updateNodeData({ systemPrompt: newPrompt });
        }}
        className="w-full h-24 rounded-lg text-black text-sm px-2 py-2 resize-none"
      />
    </div>

    {data.isRoot && (
      <div className="flex flex-col justify-center items-center w-full gap-2">
        <h2 className="text-md font-semibold">User Query</h2>
        <textarea
          value={userQuery}
          onChange={(e) => {
            const newQuery = e.target.value;
            setUserQuery(newQuery);
            updateNodeData({ userQuery: newQuery });
          }}
          className="w-full h-24 rounded-lg text-black text-sm px-2 py-2 resize-none"
        />
      </div>
    )}
  </>
);

----- Content End -----

===== File: components/FlowControls.tsx =====
Type: .tsx
----- Content Start -----
import React from "react";

type FlowControlsProps = {
  showAddOptions: boolean;
  setShowAddOptions: (show: boolean) => void;
  handleAddNode: (isRoot: boolean) => void;
  processFlow: () => void;
  stopFlow: () => void; // new prop
  isProcessing: boolean;
  mounted: boolean;
};

export const FlowControls: React.FC<FlowControlsProps> = ({
  showAddOptions,
  setShowAddOptions,
  handleAddNode,
  processFlow,
  stopFlow,
  isProcessing,
  mounted,
}) => (
  <div className="absolute z-10 top-8 left-8 flex gap-4">
    <div className="relative">
      <button
        onClick={() => setShowAddOptions(!showAddOptions)}
        className="bg-gray-900 text-white text-5xl rounded-full w-16 h-16 flex items-center justify-center"
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          strokeWidth={2}
          stroke="currentColor"
          className="w-6 h-6"
        >
          {showAddOptions ? (
            <path strokeLinecap="round" strokeLinejoin="round" d="M4 12h16" />
          ) : (
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              d="M12 4v16m8-8H4"
            />
          )}
        </svg>
      </button>

      {mounted && (
        <div
          className={`absolute left-0 mt-2 w-32 bg-gray-900 rounded-lg shadow-md transition-transform duration-200 transform origin-top ${
            showAddOptions ? "scale-y-100" : "scale-y-0 pointer-events-none"
          }`}
        >
          <button
            onClick={() => {
              setShowAddOptions(!showAddOptions);
              handleAddNode(true);
            }}
            className="block w-full text-white px-4 py-2 text-left hover:bg-gray-800 rounded-t-lg"
          >
            Add Root Node
          </button>
          <button
            onClick={() => {
              setShowAddOptions(!showAddOptions);
              handleAddNode(false);
            }}
            className="block w-full text-white px-4 py-2 text-left hover:bg-gray-800 rounded-b-lg"
          >
            Add Child Node
          </button>
        </div>
      )}
    </div>

    <button
      onClick={isProcessing ? stopFlow : processFlow}
      className="bg-gray-900 text-white rounded-full w-16 h-16 flex items-center justify-center hover:bg-gray-800"
    >
      {isProcessing ? (
        // Stop icon: a simple square
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="currentColor"
          viewBox="0 0 24 24"
          className="w-6 h-6"
        >
          <rect x="6" y="6" width="12" height="12" />
        </svg>
      ) : (
        // Play icon
        <svg
          xmlns="http://www.w3.org/2000/svg"
          fill="none"
          viewBox="0 0 24 24"
          strokeWidth={2}
          stroke="currentColor"
          className="w-6 h-6"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.347a1.125 1.125 0 0 1 0 1.972l-11.54 6.347c-.75.412-1.667-.13-1.667-.986V5.653Z"
          />
        </svg>
      )}
    </button>
  </div>
);

----- Content End -----

===== File: components/ApiKeyInput.tsx =====
Type: .tsx
----- Content Start -----
import React, { useState, useEffect } from "react";
import { useApiKey } from "@/contexts/ApiKeyContext";

export const ApiKeyInput: React.FC = () => {
  const { apiKey, setApiKey } = useApiKey();
  const [inputValue, setInputValue] = useState(apiKey);

  // Update the input value when the context's apiKey changes
  useEffect(() => {
    setInputValue(apiKey);
  }, [apiKey]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    setApiKey(inputValue);
    alert("API key saved securely.");
  };

  return (
    <div className="absolute z-20 top-0 right-0 m-4">
      <form
        onSubmit={handleSubmit}
        className="w-full flex justify-center items-center gap-4"
      >
        <input
          type="password"
          placeholder="Enter your OpenAI API key"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          className="px-4 py-2 rounded-xl border"
        />
        <button
          type="submit"
          className="bg-gray-800 text-white px-4 py-2 rounded-xl"
        >
          Save
        </button>
      </form>
    </div>
  );
};

----- Content End -----

===== File: components/FlowEditor.tsx =====
Type: .tsx
----- Content Start -----
import React, { useState, useEffect } from "react";
import {
  ReactFlow,
  MiniMap,
  Controls,
  Background,
  BackgroundVariant,
} from "@xyflow/react";
import "@xyflow/react/dist/style.css";
import { CustomNode } from "./CustomNode";
import { FlowControls } from "./FlowControls";
import { useNodeManagement } from "../hooks/useNodeManagement";
import { useFlowProcessing } from "../hooks/useFlowProcessing";
import { ApiKeyInput } from "./ApiKeyInput";

export const FlowEditor: React.FC = () => {
  const {
    nodes,
    edges,
    setNodes,
    onNodesChange,
    onEdgesChange,
    onConnect,
    handleAddNode,
  } = useNodeManagement();

  const { processFlow, stopFlow, isProcessing } = useFlowProcessing(
    nodes,
    edges,
    setNodes
  );

  const [mounted, setMounted] = useState(false);
  const [showAddOptions, setShowAddOptions] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  return (
    <>
      <ApiKeyInput />
      <FlowControls
        showAddOptions={showAddOptions}
        setShowAddOptions={setShowAddOptions}
        handleAddNode={handleAddNode}
        processFlow={processFlow}
        isProcessing={isProcessing}
        stopFlow={stopFlow} // pass the new stopFlow prop
        mounted={mounted}
      />

      <div style={{ width: "100vw", height: "100vh" }}>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onConnect={onConnect}
          nodeTypes={{ customNode: CustomNode }}
          defaultEdgeOptions={{
            style: { strokeWidth: 8 },
          }}
        >
          <Controls />
          <MiniMap />
          <Background variant={BackgroundVariant.Dots} gap={12} size={1} />
        </ReactFlow>
      </div>
    </>
  );
};

export default FlowEditor;

----- Content End -----

===== File: hooks/useNodeProcessing.ts =====
Type: .ts
----- Content Start -----
import { Node } from "@xyflow/react";
import { NodeData } from "../types/flowTypes";
import { getLLMResponse } from "@/services/llmService";
import { useApiKey } from "@/contexts/ApiKeyContext";

export const useNodeProcessing = (
  setNodes: React.Dispatch<React.SetStateAction<Node<NodeData>[]>>
) => {
  const { apiKey } = useApiKey();
  const processNode = async (
    node: Node<NodeData>,
    input: string
  ): Promise<string> => {
    setNodes((nds) =>
      nds.map((n) =>
        n.id === node.id
          ? { ...n, data: { ...n.data, isProcessing: true, error: undefined } }
          : n
      )
    );

    try {
      const response = await getLLMResponse(
        apiKey,
        node.data.systemPrompt,
        input
      );
      setNodes((nds) =>
        nds.map((n) =>
          n.id === node.id
            ? {
                ...n,
                data: {
                  ...n.data,
                  output: response.output,
                  isProcessing: false,
                },
              }
            : n
        )
      );
      return response.output;
    } catch (error) {
      setNodes((nds) =>
        nds.map((n) =>
          n.id === node.id
            ? {
                ...n,
                data: {
                  ...n.data,
                  error: "Error processing node",
                  isProcessing: false,
                },
              }
            : n
        )
      );
      throw error;
    }
  };

  return { processNode };
};

----- Content End -----

===== File: hooks/useNodeManagement.ts =====
Type: .ts
----- Content Start -----
import { useCallback } from "react";
import {
  Node,
  Connection,
  Edge,
  useNodesState,
  useEdgesState,
  addEdge,
} from "@xyflow/react";

import { NodeData } from "@/types/flowTypes";

const initialNodes: Node<NodeData>[] = [
  {
    id: "1",
    type: "customNode",
    position: { x: 200, y: 50 },
    data: {
      label: "Root Node",
      systemPrompt: "You are a helpful assistant.",
      userQuery: "What are the implications of AI?",
      isRoot: true,
      output: "",
      isProcessing: false,
    },
  },
];

const initialEdges: Edge[] = [];

export const useNodeManagement = () => {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState<Edge>(initialEdges);

  const onConnect = useCallback(
    (params: Connection) => {
      const edge: Edge = {
        id: `e${params.source}-${params.target}`,
        source: params.source,
        target: params.target,
        type: "default",
      };
      setEdges((eds) => addEdge(edge, eds));
    },
    [setEdges]
  );

  const handleAddNode = useCallback(
    (isRoot: boolean) => {
      const id = (nodes.length + 1).toString();
      const newNode: Node<NodeData> = {
        id,
        type: "customNode",
        position: {
          x: Math.random() * 500 + 50,
          y: Math.random() * 500 + 50,
        },
        data: {
          label: isRoot ? "Root Node" : "New Node",
          systemPrompt: isRoot
            ? "You are a helpful assistant."
            : "Default prompt",
          isRoot,
          output: "",
          isProcessing: false,
        },
      };
      setNodes((ns) => [...ns, newNode]);
    },
    [nodes, setNodes]
  );

  return {
    nodes,
    edges,
    setNodes,
    onNodesChange,
    onEdgesChange,
    onConnect,
    handleAddNode,
  };
};

----- Content End -----

===== File: hooks/useFlowProcessing.ts =====
Type: .ts
----- Content Start -----
import { useState, useRef } from "react";
import { Node, Edge, getOutgoers } from "@xyflow/react";
import { NodeData } from "../types/flowTypes";
import { useNodeProcessing } from "./useNodeProcessing";

export const useFlowProcessing = (
  nodes: Node<NodeData>[],
  edges: Edge[],
  setNodes: React.Dispatch<React.SetStateAction<Node<NodeData>[]>>
) => {
  const [isProcessing, setIsProcessing] = useState(false);
  const cancelProcessingRef = useRef(false);
  const { processNode } = useNodeProcessing(setNodes);

  const processNodeAndDescendants = async (
    node: Node<NodeData>,
    input?: string
  ) => {
    // If processing has been cancelled, stop immediately.
    if (cancelProcessingRef.current) return;

    const effectiveInput = node.data.isRoot
      ? node.data.userQuery || ""
      : input || "";
    const output = await processNode(node, effectiveInput);

    // Check cancellation between nodes.
    if (cancelProcessingRef.current) return;

    const outgoers = getOutgoers(node, nodes, edges);
    for (const outgoer of outgoers) {
      await processNodeAndDescendants(outgoer as Node<NodeData>, output);
      if (cancelProcessingRef.current) break;
    }

    return output;
  };

  const processFlow = async () => {
    if (isProcessing) return;
    cancelProcessingRef.current = false;
    setIsProcessing(true);

    try {
      // Reset all node states before processing.
      setNodes((nodes) =>
        nodes.map((node) => ({
          ...node,
          data: {
            ...node.data,
            output: "",
            error: undefined,
            isProcessing: false,
          },
        }))
      );

      const rootNodes = nodes.filter((node) => node.data.isRoot);
      // Process all root nodes concurrently.
      await Promise.all(
        rootNodes.map((rootNode) => processNodeAndDescendants(rootNode))
      );
    } catch (error) {
      console.error("Error processing flow:", error);
    } finally {
      setIsProcessing(false);
    }
  };

  // New stopFlow function to cancel processing.
  const stopFlow = () => {
    cancelProcessingRef.current = true;
    setIsProcessing(false);
  };

  return { processFlow, stopFlow, isProcessing };
};

----- Content End -----

===== File: types/flowTypes.ts =====
Type: .ts
----- Content Start -----
export type NodeData = {
  label: string;
  systemPrompt: string;
  userQuery?: string;
  isRoot: boolean;
  output?: string;
  isProcessing?: boolean;
  error?: string;
};

export type LLMResponse = {
  output: string;
  error?: string;
};

----- Content End -----

===== File: services/llmService.ts =====
Type: .ts
----- Content Start -----
import OpenAI from "openai";
import { LLMResponse } from "@/types/flowTypes";

export const getLLMResponse = async (
  apiKey: string,
  systemPrompt: string,
  input: string
): Promise<LLMResponse> => {
  if (!apiKey) {
    return { output: "", error: "No API key provided." };
  }

  const openai = new OpenAI({
    apiKey,
    dangerouslyAllowBrowser: true,
  });

  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: input },
      ],
    });

    const output = response.choices[0]?.message?.content || "";
    return { output };
  } catch (error) {
    console.error("Error fetching LLM response:", error);
    return { output: "", error: "Failed to fetch response from LLM." };
  }
};

----- Content End -----

===== File: contexts/ApiKeyContext.tsx =====
Type: .tsx
----- Content Start -----
"use client";

import React, { createContext, useState, useContext, useEffect } from "react";

interface ApiKeyContextType {
  apiKey: string;
  setApiKey: (key: string) => void;
}

const ApiKeyContext = createContext<ApiKeyContextType | undefined>(undefined);

export const ApiKeyProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [apiKey, setApiKey] = useState("");

  // On mount, check if there's an API key stored in localStorage
  useEffect(() => {
    const storedApiKey = localStorage.getItem("apiKey");
    if (storedApiKey) {
      setApiKey(storedApiKey);
    }
  }, []);

  // Whenever the API key changes, update localStorage
  useEffect(() => {
    if (apiKey) {
      localStorage.setItem("apiKey", apiKey);
    }
  }, [apiKey]);

  return (
    <ApiKeyContext.Provider value={{ apiKey, setApiKey }}>
      {children}
    </ApiKeyContext.Provider>
  );
};

export const useApiKey = (): ApiKeyContextType => {
  const context = useContext(ApiKeyContext);
  if (context === undefined) {
    throw new Error("useApiKey must be used within an ApiKeyProvider");
  }
  return context;
};

----- Content End -----

